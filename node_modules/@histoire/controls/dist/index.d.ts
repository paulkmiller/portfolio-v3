export declare const HstButton: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
            };
        }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        color: {
            type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    color: {
        type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default: (_: {}) => any;
    };
});
export declare const HstButtonGroup: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", value: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string) => void;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string) => void;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstCheckbox: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", newValue: boolean | "true" | "false") => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            'update:modelValue': (newValue: boolean | "true" | "false") => true;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        modelValue: {
            type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
        };
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    modelValue: {
        type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
    };
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: boolean | "true" | "false") => true;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstCheckboxList: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", value: string[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string[]) => void;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string[]>;
            required: true;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string[]) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string[]>;
        required: true;
    };
    options: {
        type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string[]) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string[]) => void;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstText: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", newValue: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            'update:modelValue': (newValue: string) => true;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: string) => true;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstNumber: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", newValue: number) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            'update:modelValue': (newValue: number) => true;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: number) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: number) => true;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstSlider: import("@vue/runtime-core").DefineComponent<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
    min: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
    max: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: number) => true;
}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
    min: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
    max: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: number) => any;
}, {}>;
export declare const HstTextarea: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", newValue: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            'update:modelValue': (newValue: string) => true;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: string) => true;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstSelect: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", value: any) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: any) => void;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<any>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: any) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<any>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: any) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: any) => void;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstColorShades: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        shades: {
            type: import("@vue/runtime-core").PropType<Record<string, any>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
        };
        search: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    shades: {
        type: import("@vue/runtime-core").PropType<Record<string, any>>;
        required: true;
    };
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
    };
    search: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default: (_: {
            color: string;
        }) => any;
    };
});
export declare const HstTokenList: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    tokens: {
        type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
        required: true;
    };
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default: (_: {
            token: {
                key: string;
                name: string;
                value: string | Record<string, any>;
            };
        }) => any;
    };
});
export declare const HstTokenGrid: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
            colSize: number;
        }> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            } & {
                default: any;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
            } & {
                default: number;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
        }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, "getName" | "colSize">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            } & {
                default: any;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
            } & {
                default: number;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
            getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
            colSize: number;
        }, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        } & {
            default: any;
        };
        colSize: {
            type: import("@vue/runtime-core").PropType<number>;
        } & {
            default: number;
        };
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
    } & {
        default: any;
    };
    colSize: {
        type: import("@vue/runtime-core").PropType<number>;
    } & {
        default: number;
    };
    tokens: {
        type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
        required: true;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
    getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
    colSize: number;
}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default: (_: {
            token: {
                key: string;
                name: string;
                value: string | Record<string, any>;
            };
        }) => any;
    };
});
export declare const HstCopyIcon: import("@vue/runtime-core").DefineComponent<{
    content: {
        type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
        required: true;
    };
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    content: {
        type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
        required: true;
    };
}>>, {}>;
export declare const HstRadio: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", value: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string) => void;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string) => void;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const HstJson: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
        $emit: (event: "update:modelValue", newValue: unknown) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            'update:modelValue': (newValue: unknown) => true;
        }, string, {}, {}, string> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<unknown>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: unknown) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<unknown>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: unknown) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    'update:modelValue': (newValue: unknown) => true;
}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions: (_: {}) => any;
    };
});
export declare const components: {
    HstButton: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                color: {
                    type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
                };
            }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                color: {
                    type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        color: {
            type: import("@vue/runtime-core").PropType<"flat" | "default" | "primary">;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default: (_: {}) => any;
        };
    });
    HstButtonGroup: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", value: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string) => void;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string) => void;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstCheckbox: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                modelValue: {
                    type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
                };
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", newValue: boolean | "true" | "false") => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                modelValue: {
                    type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
                };
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                'update:modelValue': (newValue: boolean | "true" | "false") => true;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        modelValue: {
            type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
        };
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: boolean | "true" | "false") => true;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstCheckboxList: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string[]>;
                    required: true;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string[]) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", value: string[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string[]>;
                    required: true;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string[]) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string[]) => void;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string[]>;
            required: true;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string[]) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string[]) => void;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstText: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", newValue: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                'update:modelValue': (newValue: string) => true;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: string) => true;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstNumber: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<number>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: number) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", newValue: number) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<number>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: number) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                'update:modelValue': (newValue: number) => true;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: number) => true;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstSlider: import("@vue/runtime-core").DefineComponent<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
        min: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
        max: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: number) => true;
    }, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
        min: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
        max: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    }, {}>;
    HstTextarea: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", newValue: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                'update:modelValue': (newValue: string) => true;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: string) => true;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstSelect: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<any>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: any) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", value: any) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<any>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: any) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: any) => void;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<any>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[] | Record<string, any>>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: any) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: any) => void;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstRadio: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", value: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string) => void;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string) => void;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstJson: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<unknown>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: unknown) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: "update:modelValue", newValue: unknown) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<unknown>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: unknown) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                'update:modelValue': (newValue: unknown) => true;
            }, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<unknown>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: unknown) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        'update:modelValue': (newValue: unknown) => true;
    }, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions: (_: {}) => any;
        };
    });
    HstColorShades: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                shades: {
                    type: import("@vue/runtime-core").PropType<Record<string, any>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
                };
                search: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                shades: {
                    type: import("@vue/runtime-core").PropType<Record<string, any>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
                };
                search: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        shades: {
            type: import("@vue/runtime-core").PropType<Record<string, any>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
        };
        search: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default: (_: {
                color: string;
            }) => any;
        };
    });
    HstTokenList: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                };
            }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default: (_: {
                token: {
                    key: string;
                    name: string;
                    value: string | Record<string, any>;
                };
            }) => any;
        };
    });
    HstTokenGrid: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{
                getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
                colSize: number;
            }> & Omit<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                } & {
                    default: any;
                };
                colSize: {
                    type: import("@vue/runtime-core").PropType<number>;
                } & {
                    default: number;
                };
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
            }>> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, "getName" | "colSize">;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                } & {
                    default: any;
                };
                colSize: {
                    type: import("@vue/runtime-core").PropType<number>;
                } & {
                    default: number;
                };
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
                getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
                colSize: number;
            }, {}, string> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string>, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            } & {
                default: any;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
            } & {
                default: number;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        } & {
            default: any;
        };
        colSize: {
            type: import("@vue/runtime-core").PropType<number>;
        } & {
            default: number;
        };
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
        getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
        colSize: number;
    }, {}, string> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default: (_: {
                token: {
                    key: string;
                    name: string;
                    value: string | Record<string, any>;
                };
            }) => any;
        };
    });
    HstCopyIcon: import("@vue/runtime-core").DefineComponent<{
        content: {
            type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
            required: true;
        };
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        content: {
            type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
            required: true;
        };
    }>>, {}>;
};
export * from './types';
